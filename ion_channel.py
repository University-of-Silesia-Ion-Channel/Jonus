import matplotlib.pyplot as plt
from random import choice
from scipy.stats import levy_stable
from statsmodels.graphics.tsaplots import plot_acf
import fathon
from fathon import fathonUtils as fu
import os
import numpy as np
from ipywidgets import FloatSlider, IntSlider, Dropdown, SelectionSlider, VBox, Button, Checkbox
from IPython.display import display

class IonChannel:
    """
    IonChannel
    ----------
    Class with methods to generate and analyse Ion Channel time series. 
    
    Attributes
    ----------
    data : ndarray
        Holds data generated by method ``_generate_data``.
    data_transposed : ndarray
        Holds transposed ``data``.
    breakpoints : ndarray
        Holds points at which Ion Channel changed state.

    Methods
    -------
    generate_data(random_force='Gauss'):
        Generates Ion Channel time series data
    """
    def __init__(self, a=1, closed=(-1, 6.0), opened=(1, 2.0), D=0.5, delta_t=0.01, records=50000, takes_prev_vals=True, seed=12345, **random_force_params):
        """Constructor of ``IonChannel`` class

        Parameters
        ----------
        a : int, optional
            a coefficient used in ``__model_force_square``, by default 1
        closed : tuple, optional
            ``closed[0]`` has value of current in [pA] of when channel is closed.

            ``closed[1]`` has value of average time the channel is closed. By default (-1, 6.0)
        opened : tuple, optional
            ``opened[0]`` has value of current in [pA] of when channel is opened.
            
            ``opened[1]`` has value of average time the channel is opened. By default (1, 2.0)
        D : float, optional
            Coefficient representing temperature. The larger it is the bigger the noise, by default 0.5
        delta_t : float, optional
            Time series spacing. Should be magnification of 10 to negative power, by default 0.01
        records : int, optional
            Number of records to generate, by default 50000
        takes_prev_vals : bool, optional
            Was used for testing. Keep at ``True``, by default True
        seed : int, optional
            Used for seeded generation. Creates np.random.Generator(np.random.PCG64(seed=seed)), by default 12345

        Notes
        -----
        ``closed[1]`` > ``opened[1]``
        """
        self.__a = a
        self.__closed = closed
        self.__opened = opened
        self.__D = D
        self.__delta_t = delta_t
        self.__records = records
        self.__takes_prev_vals = takes_prev_vals
        self.__random_force_params = random_force_params
        self.__generator = np.random.Generator(np.random.PCG64(seed=seed))
        self.__threshold = 0.5 
        self.data = []
        self.breakpoints = []

    def __random_force_gauss(self, records, opened_state):
        """Function generates random force values using standard gaussian distribution.

        Parameters
        ----------
        records : _int_
            Number of records to generate.
        opened_state : _bool_
            Placeholder.

        Returns
        -------
        ndarray : 
            Array with random force values.
        """
        
        return (self.__delta_t * self.__D) ** 0.5 * self.__generator.normal(0, 1, size=records)  # losowa si≈Ça
    
    def __model_force_square(self, x, b):
        """Function calculates force value using square function.

        Parameters
        ---------
        x : float 
            Position value.
        b : float 
            Coefficient.

        Returns
        -------
        float: 
            Force value at x.
        """
        return -self.__a*(x - b)
    
    # takes two common parameters and dictionary with 5 parameters needed for levy_stable.rvs function
    def __random_force_levy(self, records, opened_state):
        """Function generates random force values using ``levy_stable`` distribution.

        Parameters
        ----------
        records : int
            Number of records to generate.
        opened_state : bool 
            State of ion channel.

        Returns
        -------
        ndarray: 
            Array with random force values.
        """
        args = self.__random_force_params
        r = levy_stable.rvs(alpha=args['alpha'], beta=args['beta_opened' if opened_state else 'beta_closed'], loc=args['location'], scale=args['scale'], size=records, random_state=self.__generator)
        return (self.__delta_t * self.__D) ** 0.5 * r  # random force
    
    def _generate_data(self, random_force='Gauss'):
        """Function, that generates time series of ion channel model and saves it to csv file.

        Parameters
        ----------
        random_force : str
            Choice of noise random function. 
                - ``Gauss`` for ``__random_force_gauss``
                - ``Levy`` for ``__random_force_levy``
        """
        if random_force.lower() == str.lower('Gauss'):
            self.__random_force = self.__random_force_gauss
        else:
            self.__random_force = self.__random_force_levy

        t = 0
        # generating first state of ion channel (opened/closed)
        b = choice([self.__closed, self.__opened])
        tau = self.__generator.exponential(b[1])
        random_force_values = self.__random_force(np.int32(tau//self.__delta_t), b == self.__opened)
        
        x = np.array([self.__model_force_square(0, b[0]) * self.__delta_t + random_force_values[0]], dtype=np.float32)
        times = np.array([t], dtype=np.float32)
        self.data.append([times[0], x[0], b[0]])
        t += 1
        no_state_change = True # needed so it doesn't take previous value of previous state (closed and opened are seperated and changes are more acute)
        while t < self.__records:
            count = 0
            new_x = (
                no_state_change * self.__takes_prev_vals * x[t - 1] +
                self.__model_force_square(x[t - 1], b[0]) * self.__delta_t +
                random_force_values[t - 1]
                )
            while np.abs(np.abs(new_x) - self.__threshold) > np.abs(b[0]) and count < 100:
                # generate a new smaller x
                random_force_values[t - 1] = self.__random_force(1, b == self.__opened)[0]
                new_x = (
                    no_state_change * self.__takes_prev_vals * x[t - 1] +
                    self.__model_force_square(x[t - 1], b[0]) * self.__delta_t +
                    random_force_values[t - 1]
                    )
                count += 1 
            x = np.append(
            x, new_x
            )
            times = np.append(times, t * self.__delta_t)

            self.data.append([times[t], x[t], b[0]])
            no_state_change = True
            t += 1
            tau -= self.__delta_t
            if(tau <= self.__delta_t):
                self.breakpoints.append(times[t-1])
                if(b[0] == self.__closed[0]):
                    b=self.__opened
                else:
                    b=self.__closed
                tau = self.__generator.exponential(b[1])
                tau = 1.0 if tau < 1.0 else tau
                random_force_values = np.append(random_force_values, self.__random_force(np.int32(tau//self.__delta_t), b[0] == self.__opened[0]))
                no_state_change = False

        self.data = np.array(self.data)
        self.breakpoints = np.array(self.breakpoints)        
        self.data_transposed = self.data.T
        # Temporary naming scheme
        np.savetxt(f'outputs/data_{random_force}_{self.__D}_{self.__delta_t}_{list(self.__random_force_params.values()) if isinstance(self.__random_force_params, dict) else '_'}.csv', self.data, delimiter=',', header='time,position,state', fmt=['%.2f', '%e', '%d'])
        # return self.data, self.breakpoints
    
    def plot_time_series(self, figsize=(10, 5), title='Generated model'):
        """Plots generated time series.

        Parameters
        ----------
        figsize : tuple, optional
            Figure size, by default (10, 5)
        title : str, optional
            Title of plot, by default 'Generated model'
        
        Raises
        ------
        AssertionError
            With message "Data wasn't generated"
        """
        assert len(self.data_transposed) > 0, "Data wasn't generated"
        
        plt.clf()  
        plt.figure(figsize=figsize)
        plt.title(title)
        plt.plot(self.data_transposed[0], self.data_transposed[1])
        plt.xlabel("Time [s]")
        plt.ylabel("Current [pA]")
        plt.show()

    def plot_time_series_histogram(self, bins=100):
        """Plots histogram of time series with specified amount of ``bins``.

        Parameters
        ----------
        bins : int, optional
            Number of bins, by default 100
        """
        plt.hist(self.data_transposed[1], bins=bins)
        plt.show()

    def calculate_autocorrelation_acf(self, data, lags=30, title="test"):
        """Function calculates and plots autocorrelation function.
        
        Parameters
        ----------
        data : ndarray
            1D array containing data to calculate autocorrelation on.
        lags : int, optional
            Number of lags to calculate. Defaults to 30.
        title : str, optional
            Directory to save plot to. Defaults to "test"

        Examples:
        ---------
        >>> import numpy as np
        >>> from ion_channel import IonChannel
        >>> ic = IonChannel()
        >>> data = np.random.random(10000)
        >>> ic.calculate_autocorrelation_acf(data)
        """
        fig, axs = plt.subplots(1, 2, figsize=(12, 6))
        fig.suptitle('Autocorrelation ' + title)
        plot_acf(data, lags=lags, ax=axs[0], fft=True, title='Unmodified autocorrelation')
        plot_acf(np.diff(data), lags=lags, ax=axs[1], fft=True, title='Modified autocorrelation')
        if(not os.path.isdir(f"outputs/{title}")):
            os.mkdir(f"outputs/{title}")
        fig.savefig(f'outputs/{title}/acf.png')
        plt.show()

    def calculate_autocorrelation_dfa(self, data, title="test"):
        """ Calculates, shows and saves Detrended Fluctuation Analysis plots with Hurst exponent for autocorrelation. 
        Depending on the value of H it is:
            * H < 0.5 - anti-correlated
            * H around 0.5 - uncorrelated, white noise
            * H > 0.5 - correlated
            * H around 1 - 1/f-noise, pink noise
            * H > 1 - non-stationary, unbounded
            * H around 1.5 - Brownian noise
        ----------    

        Parameters
        ----------
        data : ndarray
            1D array containing data to calculate autocorrelation on.
        title : str, optional 
            Title of figure and directory name to save plots to. Defaults to "test".

        Examples:
        ---------
        >>> import numpy as np
        >>> from ion_channel import IonChannel
        >>> ic = IonChannel()
        >>> data = np.random.random(10000)
        >>> ic.calculate_autocorrelation_dfa(data)
        """
        a = fu.toAggregated(data)

        pydfa = fathon.DFA(a)

        winSizes = fu.linRangeByStep(5, len(a))
        revSeg = True
        polOrd = 3

        n, F = pydfa.computeFlucVec(winSizes, revSeg=revSeg, polOrd=polOrd)

        H, H_intercept = pydfa.fitFlucVec()
        plt.title('DFA ' + title)
        plt.plot(np.log(n), np.log(F), 'ro')
        plt.plot(np.log(n), H_intercept+H*np.log(n), 'k-', label='H = {:.2f}'.format(H))
        plt.xlabel('ln(n)', fontsize=14)
        plt.ylabel('ln(F(n))', fontsize=14)
        plt.legend(loc=0, fontsize=14)

        if(not os.path.isdir(f"outputs/{title}")):
            os.mkdir(f"outputs/{title}")
        plt.savefig(f'outputs/{title}/dfa.png')
        plt.show()

    
class InteractiveIonChannel():
    """
    InteractiveIonChannel
    ---------------------
    Helper class for ``IonChannel``. Creates easy to manage interactive widget for ``IonChannel`` creation.

    Examples
    --------
    >>> from ion_channel import InteractiveIonChannel
    >>> interactive_ion_channel = InteractiveIonChannel()
    >>> interactive_ion_channel.interact()
    """
    def __init__(self):
        """Constructor of InteractiveIonChannel class
        """
        self.__a_slider = FloatSlider(min=0.0, max=10.0, step=0.1, value=1, description='a')
        self.__closed_0_slider = IntSlider(min=-10, max=10, step=1, value=-1, description='Closed value')
        self.__closed_1_slider = FloatSlider(min=0.0, max=100.0, step=0.1, value=6.0, description='Closed avg time')
        self.__opened_0_slider = IntSlider(min=-10, max=10, step=1, value=1, description='Opened value')
        self.__opened_1_slider = FloatSlider(min=0.0, max=100.0, step=0.1, value=2.0, description='Opened avg time')
        self.__D_slider = FloatSlider(min=0.1, max=100.0, step=0.1, value=2.0, description='D')
        self.__delta_t_slider = SelectionSlider(
            options=[10**-i for i in range(1, 5)],
            value=0.01,
            description='Delta t',
        )
        self.__records_slider = IntSlider(min=1000, max=100000, step=1000, value=50000, description='Records')

        self.__random_force_dropdown = Dropdown(
            options = ['Gauss', 'Levy'],
            value = 'Gauss',
            description = 'Random Force',
        )

        self.__autocorrelation_dropdown = Dropdown(
            options = ['DFA', 'FFT', 'Both'],
            value = 'Both',
            description = 'Autocorrelation method'
        )
        self.__takes_previous = Checkbox(value=True, description='Takes previous values')
        self.__seed_select = IntSlider(min=0, max=99999, value=12345, step=1, description='Seed')
        self.__force_params_box = VBox()

    def __ion_channel_interactive(self, a, closed_0, closed_1, opened_0, opened_1, D, delta_t, records, random_force, takes_previous, seed, **force_params):
        """
        Generates an interactive widget for the ion channel model.
        """
        closed = (closed_0, closed_1)
        opened = (opened_0, opened_1)
        self.ion_channel = IonChannel(a, closed, opened, D, delta_t, records, takes_prev_vals=takes_previous, seed=seed, **force_params)
        self.ion_channel._generate_data(random_force)
    
    def __update_force_params(self, *args):
        """
        Updates the force_params_box based on the selected random force.
        """
        force_type = self.__random_force_dropdown.value
        if force_type.lower() == str.lower('Levy'):
            # Define widgets specific to 'Other Force'
            alpha = FloatSlider(min=0, max=2, step=0.01, value=1.9, description='alpha')
            beta_opened = FloatSlider(min=-1.0, max=0.0, step=0.01, value=-1.0, description='beta_opened')
            beta_closed = FloatSlider(min=0.0, max=1, step=0.01, value=1.0, description='beta_closed')
            loc = IntSlider(min=0, max=100, step=1, value=0, description='location')
            scale = FloatSlider(min=0, max=100, step=0.1, value=0.1, description='scale')
            self.__force_params_box.children = [alpha, beta_closed, beta_opened, loc, scale]
        else:
            self.__force_params_box.children = []
    
    def interact(self):
        """Main function to call on ``InteractiveIonChannel`` class. 

        Creates interactive ``ipywidget``, that user can initialize ``IonChannel`` with.
        """
        self.__random_force_dropdown.observe(self.__update_force_params, names='value')

        display(
            self.__seed_select,
            self.__a_slider,
            self.__closed_0_slider,
            self.__closed_1_slider,
            self.__opened_0_slider,
            self.__opened_1_slider,
            self.__D_slider,
            self.__delta_t_slider,
            self.__records_slider,
            self.__force_params_box,
            self.__takes_previous,
            self.__random_force_dropdown,
            self.__autocorrelation_dropdown
        )
        run_button = Button(description="Run Model")
        run_button.on_click(self.__on_button_click)
        display(run_button)

    def __on_button_click(self, b):
        """
        Callback for the 'Run Model' button.
        """
        print("Button Clicked")
        force_params = {child.description: child.value for child in self.__force_params_box.children}
        self.__ion_channel_interactive(
            self.__a_slider.value,
            self.__closed_0_slider.value,
            self.__closed_1_slider.value,
            self.__opened_0_slider.value,
            self.__opened_1_slider.value,
            self.__D_slider.value,
            self.__delta_t_slider.value,
            self.__records_slider.value,
            self.__random_force_dropdown.value,
            self.__takes_previous.value,
            self.__seed_select.value,
            **force_params
        )
        
        params_str = (
            f"a: {self.__a_slider.value}, "
            f"closed_0: {self.__closed_0_slider.value}, "
            f"closed_1: {self.__closed_1_slider.value}, "
            f"opened_0: {self.__opened_0_slider.value}, "
            f"opened_1: {self.__opened_1_slider.value}, "
            f"D: {self.__D_slider.value}, "
            f"delta_t: {self.__delta_t_slider.value}, "
            f"records: {self.__records_slider.value}, "
            f"random_force: {self.__random_force_dropdown.label}, "
            f"force_params: {', '.join([f'{key}: {value}' for key, value in force_params.items()])} "
            f"seed: {self.__seed_select.value}"
        )
        self.ion_channel.plot_time_series()
        self.ion_channel.plot_time_series_histogram()
        print(params_str)
        name = f"{self.__random_force_dropdown.value}_D{self.__D_slider.value}_a{self.__a_slider.value}_{self.__takes_previous.value}_{self.__seed_select.value}"
        data = self.ion_channel.data_transposed[1] # because self.data is shape (records, 3)
        match self.__autocorrelation_dropdown.value:
            case 'DFA': 
                self.ion_channel.calculate_autocorrelation_dfa(data, title=name)
            case 'FFT':
                self.ion_channel.calculate_autocorrelation_acf(data, title=name)
            case _:
                self.ion_channel.calculate_autocorrelation_acf(data, title=name)   
                self.ion_channel.calculate_autocorrelation_dfa(data, title=name)