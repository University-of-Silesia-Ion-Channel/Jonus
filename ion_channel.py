import matplotlib.pyplot as plt
import matplotlib.transforms as mtransforms
from scipy.stats import levy_stable
from statsmodels.graphics.tsaplots import plot_acf
import fathon
from fathon import fathonUtils as fu
import os
import numpy as np
from ipywidgets import FloatSlider, IntSlider, Dropdown, SelectionSlider, VBox, Button, Checkbox
from IPython.display import display
from matplotlib import colors

class IonChannel:
    """
    IonChannel
    ----------
    Class with methods to generate and analyse Ion Channel time series. 
    
    Attributes
    ----------
    data : ndarray
        Holds data generated by method ``_generate_data``.
    data_transposed : ndarray
        Holds transposed ``data``.
    breakpoints : ndarray
        Holds points at which Ion Channel changed state.

    Methods
    -------
    generate_data(random_force='Gauss'):
        Generates Ion Channel time series data
    """

    def __init__(self, a=100, k=1, L=1, closed=(-1, 48.0), opened=(1, 12.0), D=2.0, delta_t=0.0001, records=50000, takes_prev_vals=True, seed=12345, **random_force_params):
        """Constructor of ``IonChannel`` class

        Parameters
        ----------
        a : int, optional
            a coefficient used in ``__model_force_square``, by default 100
        closed : tuple, optional
            ``closed[0]`` has value of current in [pA] of when channel is closed.

            ``closed[1]`` has value of average time the channel is closed. By default (-1, 48.0)
        opened : tuple, optional
            ``opened[0]`` has value of current in [pA] of when channel is opened.
            
            ``opened[1]`` has value of average time the channel is opened. By default (1, 12.0)
        D : float, optional
            Coefficient representing temperature. The larger it is the bigger the noise, by default 2.0
        delta_t : float, optional
            Time series spacing. Should be magnification of 10 to negative power, by default 0.0001
        records : int, optional
            Number of records to generate, by default 50000
        takes_prev_vals : bool, optional
            Was used for testing. Keep at ``True``, by default True
        seed : int, optional
            Used for seeded generation. Creates ``np.random.Generator(np.random.PCG64(seed=seed))``, by default 12345

        Notes
        -----
        ``closed[1]`` > ``opened[1]``
        """
        # assert closed[1] > opened[1], "Closed state is on average open longer than opened."
        self.__a = a
        self.__k = k
        self.__L = L
        self.__closed = list(closed)
        self.__opened = list(opened)
        self.__closed[1] = self.__closed[1]*delta_t*100
        self.__opened[1] = self.__opened[1]*delta_t*100
        self.__D = D
        self.__delta_t = delta_t
        self.__records = records
        self.__takes_prev_vals = takes_prev_vals
        self.__random_force_params = random_force_params
        self.__generator = np.random.Generator(np.random.PCG64(seed=seed))
        self.__threshold = 6.0
        self.data = []
        self.breakpoints = []

    def __random_force_gauss(self, records):
        """Function generates random force values using standard gaussian distribution.

        Parameters
        ----------
        records : _int_
            Number of records to generate.

        Returns
        -------
        ndarray : 
            Array with random force values.
        """
        
        return (2 * self.__D * self.__delta_t) ** 0.5 * self.__generator.normal(0, 1, size=records)
    
    def __model_force_square(self, x, b):
        """Function calculates force value using square function.

        Parameters
        ---------
        x : float 
            Position value.
        b : float 
            Coefficient.

        Returns
        -------
        float: 
            Force value at x.
        """
        return -self.__a*(x - b)
    
    def __u(self, x, b):
        return (x - b) / self.__L
    
    def __model_force_asymetrical(self, x, b):
        if self.__opened_larger:
            self.__k = self.__k if self.__opened_state else -self.__k
        else:
            self.__k = -self.__k if self.__opened_state else self.__k
        u_x = self.__u(x, b)
        return -(self.__a*self.__L) * (u_x + self.__k * (u_x) ** 2 + (self.__k ** 2 * (u_x) ** 3) / 2 - (self.__k * u_x **4) / 3)

    def __model_force_e(self, x, b):
        if self.__opened_larger:
            k = self.__k if self.__opened_state else -self.__k
        else:
            k = -self.__k if self.__opened_state else self.__k
        return self.__model_force_square * np.e ** (self.__k * np.tanh((x - b) / self.__L))

    def __model_force_a(self, x, b):
        if self.__opened_larger:
            k = self.__k if self.__opened_state else (-self.__k)
        else:
            k = (-self.__k) if self.__opened_state else self.__k
        return self.__model_force_square(x, b) * np.e**(k*(x-b))

    def __random_force_levy(self, records):
        """Function generates random force values using ``levy_stable`` distribution.

        Parameters
        ----------
        records : int
            Number of records to generate.

        Returns
        -------
        ndarray: 
            Array with random force values.
        """
        args = self.__random_force_params
        if self.__opened_larger:
            r = levy_stable.rvs(alpha=args['alpha'], beta=-args['beta'] if self.__opened_state else args['beta'], loc=0.0, scale=args['scale'], size=records, random_state=self.__generator)
        else:
            r = levy_stable.rvs(alpha=args['alpha'], beta=args['beta'] if self.__opened_state else -args['beta'], loc=0.0, scale=args['scale'], size=records, random_state=self.__generator)
        return (2 * self.__delta_t * self.__D) ** 0.5 * r  # random force
    
    def _generate_data(self, model_force="Square", random_force='Gauss'):
        """Function, that generates time series of ion channel model and saves it to csv file.

        Parameters
        ----------
        random_force : str
            Choice of noise random function. 
                - ``Gauss`` for ``__random_force_gauss``
                - ``Levy`` for ``__random_force_levy``
        """
        if random_force.lower() == str.lower('Gauss'):
            self.__random_force = self.__random_force_gauss
        else:
            self.__random_force = self.__random_force_levy

        match model_force.lower() :
            case "square":
                self.__model_force = self.__model_force_square
            case "asymetrical":
                self.__model_force = self.__model_force_asymetrical
            case "e":
                self.__model_force = self.__model_force_e
            case "a":
                self.__model_force = self.__model_force_a
        t = 0
        self.dwell_times = []
        # generating first state of ion channel (opened/closed)
        b = self.__generator.choice([self.__closed, self.__opened])
        tau = self.__generator.exponential(b[1])
        self.dwell_times.append(tau)    
        self.__opened_larger = self.__opened[0] > self.__closed[0]
        self.__opened_state = b[0] == self.__opened[0]
        random_force_values = self.__random_force(np.int32(tau//self.__delta_t))
        
        x = np.array([b[0]], dtype=np.float32)
        times = np.linspace(0, self.__records*self.__delta_t, self.__records, endpoint=False)
        self.data.append([times[0], x[0], b[0]])
        t += 1
        # for more acute changes
        self.__no_state_change = True
        while t < self.__records:
            count = 0
            prev_x = x[t - 1] if self.__no_state_change else b[0]
            new_x = (
                self.__takes_prev_vals * prev_x +
                self.__model_force(prev_x, b[0]) * self.__delta_t +
                random_force_values[t - 1]
                )
            while np.abs(new_x - b[0]) > self.__threshold and count < 100:
                # generate a new smaller x
                prev_x = x[t - 1] if self.__no_state_change else b[0]
                self.__opened_state = b[0] == self.__opened[0]
                random_force_values[t - 1] = self.__random_force(1)[0]
                new_x = (
                    self.__takes_prev_vals * prev_x +
                    self.__model_force(prev_x, b[0]) * self.__delta_t +
                    random_force_values[t - 1]
                    )
                count += 1 

            # for more acute changes
            self.__no_state_change = True

            x = np.append(x, new_x)
            self.data.append([times[t], x[t], b[0]])
            t += 1
            tau -= self.__delta_t
            if(tau - self.__delta_t < self.__delta_t):
                self.breakpoints.append(times[t-1])
                if(b[0] == self.__closed[0]):
                    b=self.__opened
                else:
                    b=self.__closed
                tau = self.__generator.exponential(b[1])
                self.dwell_times.append(tau)
                self.__opened_state = b[0] == self.__opened[0]
                random_force_values = np.append(random_force_values, self.__random_force(np.int32(tau//self.__delta_t)))
                
                self.__no_state_change = False

        self.data = np.array(self.data)
        self.breakpoints = np.array(self.breakpoints)        
        self.data_transposed = self.data.T
        save_file = os.path.join(os.getcwd(), 'outputs', f'data_{random_force}_{self.__D}_{self.__delta_t}_{list(self.__random_force_params.values()) if isinstance(self.__random_force_params, dict) else '_'}.csv')
        np.savetxt(save_file, self.data, delimiter=',', header='time,position,state', fmt=['%e', '%e', '%d'])

    def plot_time_series(self, fig, ax : plt.Axes, title='Generated model', plot_breakpoints=False):
        """Plots generated time series.

        Parameters
        ----------
        fig : matplotlib.pyplot.Figure
            Figure on which time series is plotted.
        ax : matplotlib.pyplot.Axes
            Subplot ax to put plot into.
        title : str, optional
            Title of plot, by default 'Generated model'
        plot_breakpoints : bool
            True if lines on breakpoints should be plotted, by default False.
        
        Raises
        ------
        AssertionError
            With message "Data wasn't generated"
        """
        assert len(self.data_transposed) > 0, "Data wasn't generated"
        ax.set_title(title)
        ax.plot(self.data_transposed[0], self.data_transposed[1])
        if plot_breakpoints:
            ax.vlines(x=self.breakpoints, ymin=np.min(self.data_transposed[1]), ymax=np.max(self.data_transposed[1]), color='red', linestyle='--', alpha=0.6)
        ax.set_xlabel("Time [s]")
        ax.set_ylabel("Current [pA]")
        return fig, ax

    
    def plot_time_series_histogram(self, fig, ax, bins=100):
        """Plots histogram of time series with specified amount of ``bins``.

        Parameters
        ----------
        fig : matplotlib.pyplot.Figure
            Figure on which time series histogram is plotted.
        ax : matplotlib.pyplot.Axes
            Subplot ax to put plot into.
        bins : int, optional
            Number of bins, by default 100.
        """
        # filtered_data = self.data_transposed[1][~is_outlier(self.data_transposed[1], thresh=self.__threshold)] 
        # min, max = np.min(self.data_transposed[1]), np.max(self.data_transposed[1])
        # x_minmax = -1 + (2 * (self.data_transposed[1] - min) / (max - min))
        N, bins, patches = ax.hist(self.data_transposed[1], bins=bins)
        fracs = N / N.max()
        norm = colors.Normalize(fracs.min(), fracs.max())
        for thisfrac, thispatch in zip(fracs, patches):
            color = plt.cm.cividis(norm(thisfrac))
            thispatch.set_facecolor(color)
        
        return fig, ax

    def calculate_autocorrelation_acf(self, data, fig, ax, lags=100):
        """Function calculates and plots autocorrelation function.
        
        Parameters
        ----------
        data : ndarray
            1D array containing data to calculate autocorrelation on.
        fig : matplotlib.pyplot.Figure
            Figure on which autocorrelation is plotted.
        ax : matplotlib.pyplot.Axes
            Subplot ax to put plot into.
        lags : int, optional
            Number of lags to calculate. Defaults to 30.

        Examples:
        ---------
        >>> import numpy as np
        >>> from ion_channel import IonChannel
        >>> ic = IonChannel()
        >>> data = np.random.random(10000)
        >>> ic.calculate_autocorrelation_acf(data)
        """
        fig = plot_acf(data, ax=ax, lags=lags, fft=True, title='FFT')
        return fig, ax

    def calculate_autocorrelation_dfa(self, data, fig, ax):
        """
        Calculates, shows and saves Detrended Fluctuation Analysis plots with Hurst exponent for autocorrelation. 
        Depending on the value of H it is:
        * H < 0.5 - anti-correlated
        * H around 0.5 - uncorrelated, white noise
        * H > 0.5 - correlated
        * H around 1 - 1/f-noise, pink noise
        * H > 1 - non-stationary, unbounded
        * H around 1.5 - Brownian noise
        ----------    

        Parameters
        ----------
        data : ndarray
            1D array containing data to calculate autocorrelation on.
        fig : matplotlib.pyplot.Figure
            Figure on which autocorrelation is plotted.
        ax : matplotlib.pyplot.Axes
            Subplot ax to put plot into.

        Examples:
        ---------
        >>> import numpy as np
        >>> from ion_channel import IonChannel
        >>> ic = IonChannel()
        >>> data = np.random.random(10000)
        >>> ic.calculate_autocorrelation_dfa(data)
        """
        a = fu.toAggregated(data)
        pydfa = fathon.DFA(a)
        winSizes = fu.linRangeByStep(5, len(a), step=5)
        
        revSeg = True
        polOrd = 3

        n, F = pydfa.computeFlucVec(winSizes, revSeg=revSeg, polOrd=polOrd)
        max_limit = np.log(winSizes[-1])
        mid_point = winSizes[int(np.round(np.e**(max_limit//2), decimals=0))]
        limits_list = np.array([[5, mid_point], [mid_point, winSizes[-1]], [5, winSizes[-1]]], dtype=int)
        list_H, list_H_intercept = pydfa.multiFitFlucVec(limits_list)

        clrs = ['k', 'b', 'm', 'c', 'y']
        stls = ['-', '--', '.-']
        ax.plot(np.log(n), np.log(F), 'ro')
        for i in range(len(list_H)):
            n_rng = np.arange(limits_list[i][0], limits_list[i][1]+1)
            ax.plot(np.log(n_rng), list_H_intercept[i]+list_H[i]*np.log(n_rng),
                    clrs[i%len(clrs)]+stls[(i//len(clrs))%len(stls)], label='H = {:.2f}'.format(list_H[i]))
        ax.set_xlabel('ln(n)', fontsize=14)
        ax.set_ylabel('ln(F(n))', fontsize=14)
        ax.set_title('DFA', fontsize=14)
        ax.legend(loc=0, fontsize=14)
        return fig, ax

    def save_figure(self, fig : plt.Figure, title : str, name = "figure", with_subfigures=True):
        """Saves ``fig`` into folder *outputs2* subfolder ``title`` and file name ``name`` .

        Parameters
        ----------
        fig : matplotlib.pyplot.Figure
            Can be figure generated by: 
            - ```calculate_autocorrelation_acf```
            - ```calculate_autocorrelation_dfa```
            - any figure
        title : str
            Folder named by what data was generated.
        name : str
            Name of figure "``name``.png".
        with_subfigures : bool
            Use only if ``fig`` is a subplot with dimensions 2x2.
        """
        path = os.path.join(os.getcwd(), 'outputs2')
        if not os.path.exists(path):
            os.mkdir(path)
        path_with_subfolder = os.path.join(path, title)
        if not os.path.exists(path_with_subfolder):
            os.mkdir(path_with_subfolder)
        fig.savefig(os.path.join(path_with_subfolder, f"{name}.png"))
        if with_subfigures:
            transformation = fig.transFigure - fig.dpi_scale_trans
            fig.savefig(os.path.join(path_with_subfolder, 'sub_figure1.png'), bbox_inches=mtransforms.Bbox([[0, 0], [0.5, 0.495]]).transformed(transformation))
            fig.savefig(os.path.join(path_with_subfolder, 'sub_figure2.png'), bbox_inches=mtransforms.Bbox([[0.5, 0], [1.0, 0.5]]).transformed(transformation))
            fig.savefig(os.path.join(path_with_subfolder, 'sub_figure3.png'), bbox_inches=mtransforms.Bbox([[0, 0.485], [0.5, 0.978]]).transformed(transformation))
            fig.savefig(os.path.join(path_with_subfolder, 'sub_figure4.png'), bbox_inches=mtransforms.Bbox([[0.5, 0.485], [1, 0.978]]).transformed(transformation))

class InteractiveIonChannel():
    """
    InteractiveIonChannel
    ---------------------
    Helper class for ``IonChannel``. Creates easy to manage interactive widget for ``IonChannel`` creation.

    Examples
    --------
    >>> from ion_channel import InteractiveIonChannel
    >>> interactive_ion_channel = InteractiveIonChannel()
    >>> interactive_ion_channel.interact()
    """
    def __init__(self):
        """Constructor of InteractiveIonChannel class
        """
        self.__a_slider = FloatSlider(min=0.0, max=5000.0, step=1, value=1000.0, description='a')

        self.__k_slider = FloatSlider(min=-10.0, max=10.0, step=0.01, value=1.0, description='k')
        self.__L_slider = FloatSlider(min=0.0, max=100.0, step=1.0, value=50.0, description='L')

        self.__closed_0_slider = IntSlider(min=-50, max=50, step=1, value=-38, description='Closed value')
        self.__closed_1_slider = FloatSlider(min=0.0, max=100.0, step=0.1, value=9.0, description='Closed avg time(scaled by delta_t)')
        self.__opened_0_slider = IntSlider(min=-50, max=50, step=1, value=-34, description='Opened value')
        self.__opened_1_slider = FloatSlider(min=0.0, max=100.0, step=0.1, value=2.0, description='Opened avg time(scaled by delta_t)')
        self.__D_slider = FloatSlider(min=0.00, max=1000.0, step=0.1, value=100.0, description='D')
        self.__delta_t_slider = SelectionSlider(
            options=[10**-i for i in range(3, 6)],
            value=0.0001,
            description='Delta t',
        )
        self.__records_slider = IntSlider(min=1000, max=100000, step=1000, value=50000, description='Records')

        self.__random_force_dropdown = Dropdown(
            options = ['Gauss', 'Levy'],
            value = 'Gauss',
            description = 'Random Force',
        )

        self.__autocorrelation_dropdown = Dropdown(
            options = ['DFA', 'FFT', 'All'],
            value = 'All',
            description = 'Autocorrelation method'
        )

        self.__force_dropdown = Dropdown(
            options = ['Square', 'Asymetrical', 'E', 'A'],
            value = 'Square',
            description = 'Model force'
        )

        self.__fft_lags = IntSlider(min=30, max=200, step=10, value=100, description='FFT lags')
        self.__takes_previous = Checkbox(value=True, description='Takes previous values')
        self.__draw_vlines_at_breakpoint = Checkbox(value=False, description='Draw breakpoints')
        self.__seed_select = IntSlider(min=0, max=99999, value=12345, step=1, description='Seed')
        self.__force_params_box = VBox()

    def __ion_channel_interactive(self, a, k, L, closed_0, closed_1, opened_0, opened_1, D, delta_t, records, random_force, model_force, takes_previous, seed, **force_params):
        """
        Generates an interactive widget for the ion channel model.
        """
        closed = (closed_0, closed_1)
        opened = (opened_0, opened_1)
        self.ion_channel = IonChannel(a, k, L, closed, opened, D, delta_t, records, takes_prev_vals=takes_previous, seed=seed, **force_params)
        self.ion_channel._generate_data(model_force, random_force)
    
    def __update_force_params(self, *args):
        """
        Updates the force_params_box based on the selected random force.
        """
        force_type = self.__random_force_dropdown.value
        if force_type.lower() == str.lower('Levy'):
            # Define widgets specific to 'Other Force'
            alpha = FloatSlider(min=1.5, max=1.99, step=0.01, value=1.9, description='alpha')
            beta = FloatSlider(min=0.0, max=1.0, step=0.01, value=1.0, description='beta')
            scale = FloatSlider(min=0, max=100, step=0.1, value=1.5, description='scale')
            self.__force_params_box.children = [alpha, beta, scale]
        else:
            self.__force_params_box.children = []
    
    def interact(self):
        """Main function to call on ``InteractiveIonChannel`` class. 

        Creates interactive ``ipywidget``, that user can initialize ``IonChannel`` with.
        """
        self.__random_force_dropdown.observe(self.__update_force_params, names='value')

        display(
            self.__seed_select,
            self.__a_slider,
            self.__k_slider,
            self.__L_slider,
            self.__closed_0_slider,
            self.__closed_1_slider,
            self.__opened_0_slider,
            self.__opened_1_slider,
            self.__D_slider,
            self.__delta_t_slider,
            self.__records_slider,
            self.__force_params_box,
            self.__takes_previous,
            self.__random_force_dropdown,
            self.__autocorrelation_dropdown,
            self.__force_dropdown,
            self.__fft_lags,
            self.__draw_vlines_at_breakpoint
        )
        run_button = Button(description="Run Model")
        run_button.on_click(self.__on_button_click)
        display(run_button)

        run_button_test = Button(description="Run Model (Test)")
        run_button_test.on_click(self.__on_button_click)
        display(run_button_test)
        

    def __on_click_event(self, D):
        """Helper method for ``__on_button_click__``. Generates data(plots) according to users input in ``interact``.
        
        Parameters
        ----------
        D : float
            Value of D.
        """
        fig, axs = plt.subplots(2, 2, constrained_layout=True)
        fig.set_size_inches(16, 12)
        self.ion_channel.plot_time_series(fig, axs[0][0], plot_breakpoints=self.__draw_vlines_at_breakpoint.value)
        self.ion_channel.plot_time_series_histogram(fig, axs[0][1])
        match self.__random_force_dropdown.value:
            case "Gauss":
                name = f"{self.__random_force_dropdown.value}_D{D}_a{self.__a_slider.value}_k{self.__k_slider.value}_L{self.__L_slider.value}_{self.__seed_select.value}"
            case "Levy":
                name = f"{self.__random_force_dropdown.value}_D{D}_a{self.__a_slider.value}_k{self.__k_slider.value}_L{self.__L_slider.value}_alpha{self.force_params["alpha"]}_scale{self.force_params["scale"]}_{self.__seed_select.value}"
        data = self.ion_channel.data_transposed[1] # because self.data is shape (records, 3)
        fig.suptitle(name)
        match self.__autocorrelation_dropdown.value:
            case 'DFA': 
                fig, axs[1][0] = self.ion_channel.calculate_autocorrelation_dfa(data, fig, axs[1][0])
            case 'FFT':
                fig, axs[1][0]  = self.ion_channel.calculate_autocorrelation_acf(data, fig, axs[1][0], lags=self.__fft_lags.value)
            case _:
                fig, axs[1][0] = self.ion_channel.calculate_autocorrelation_acf(data, fig, axs[1][0], lags=self.__fft_lags.value)
                fig, axs[1][1] = self.ion_channel.calculate_autocorrelation_dfa(data, fig, axs[1][1])

        self.ion_channel.save_figure(fig, title=name)

    def __multi_on_click_event(self, index):
        data = self.ion_channel.data_transposed[1]
        self.__fig_autocorr, self.__axs_autocorr[index][0] = self.ion_channel.calculate_autocorrelation_acf(data, self.__fig_autocorr, self.__axs_autocorr[index][0], lags=self.__fft_lags.value)
        self.__fig_autocorr, self.__axs_autocorr[index][1] = self.ion_channel.calculate_autocorrelation_dfa(data, self.__fig_autocorr, self.__axs_autocorr[index][1])
        

    def __on_button_click(self, b : Button):
        """
        Callback for the 'Run Model'/'Run Model (test)' button.
        """
        self.force_params = {child.description: child.value for child in self.__force_params_box.children}
        if (b.description == 'Run Model'):
            self.__ion_channel_interactive(
                self.__a_slider.value,
                self.__k_slider.value,
                self.__L_slider.value,
                self.__closed_0_slider.value,
                self.__closed_1_slider.value,
                self.__opened_0_slider.value,
                self.__opened_1_slider.value,
                self.__D_slider.value,
                self.__delta_t_slider.value,
                self.__records_slider.value,
                self.__random_force_dropdown.value,
                self.__force_dropdown.value,
                self.__takes_previous.value,
                self.__seed_select.value,
                **self.force_params
            )
            self.__on_click_event(self.__D_slider.value)
        else:
            D_list = [50, 100, 150, 200, 300, 500]
            D_count = len(D_list)
            self.__fig_autocorr , self.__axs_autocorr = plt.subplots(D_count, 2, constrained_layout=True)
            self.__fig_autocorr.set_size_inches(12, 4 * D_count)
            for ind, D in enumerate(D_list):
                self.__ion_channel_interactive(
                    self.__a_slider.value,
                    self.__k_slider.value,
                    self.__L_slider.value,
                    self.__closed_0_slider.value,
                    self.__closed_1_slider.value,
                    self.__opened_0_slider.value,
                    self.__opened_1_slider.value,
                    D,
                    self.__delta_t_slider.value,
                    self.__records_slider.value,
                    self.__random_force_dropdown.value,
                    self.__force_dropdown.value,
                    self.__takes_previous.value,
                    self.__seed_select.value,
                    **self.force_params
                )
                self.__on_click_event(D)
                self.__multi_on_click_event(index = ind)
            name = f"{self.__random_force_dropdown.value}"
            self.__fig_autocorr.suptitle(name + f" D = {D_list}")
            self.ion_channel.save_figure(self.__fig_autocorr, title=name, with_subfigures = False)
           